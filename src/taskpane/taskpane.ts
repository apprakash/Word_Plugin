/*
 * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
 * See LICENSE in the project root for license information.
 */

/* global document, Office, Word */

/// <reference types="office-js" />

// Interface for chat messages
interface ChatMessage {
  content: string;
  sender: 'user' | 'assistant';
  timestamp: Date;
}

// Interface for past conversations
interface Conversation {
  id: string;
  title: string;
  timestamp: Date;
  messages: ChatMessage[];
}

// Store for conversations
let conversations: Conversation[] = [];
let currentConversation: Conversation | null = null;

Office.onReady((info) => {
  if (info.host === Office.HostType.Word) {
    document.getElementById("sideload-msg").style.display = "none";
    document.getElementById("app-body").style.display = "flex";
    
    // Initialize the chat interface
    initializeChatInterface();
  }
});

/**
 * Initialize the chat interface and event listeners
 */
function initializeChatInterface(): void {
  // Create a new conversation if none exists
  if (!currentConversation) {
    createNewConversation();
  }
  
  // Set up event listeners
  const sendButton = document.getElementById("send-message");
  const chatInput = document.getElementById("chat-input") as HTMLTextAreaElement;
  
  if (sendButton && chatInput) {
    // Send message on button click
    sendButton.addEventListener("click", () => {
      sendMessage();
    });
    
    // Send message on Enter key (but allow Shift+Enter for new lines)
    chatInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    });
  }
  
  // Load past conversations if any
  loadPastConversations();
}

/**
 * Create a new conversation
 */
function createNewConversation(): void {
  currentConversation = {
    id: generateId(),
    title: "New Conversation",
    timestamp: new Date(),
    messages: [{
      content: "Hello! I'm AskJunior Assistant. How can I help with your document today?",
      sender: "assistant",
      timestamp: new Date()
    }]
  };
  
  // Add to conversations array
  conversations.push(currentConversation);
  
  // Save to local storage
  saveConversations();
}

/**
 * Generate a unique ID for conversations
 */
function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

/**
 * Send a message from the user input
 */
function sendMessage(): void {
  const chatInput = document.getElementById("chat-input") as HTMLTextAreaElement;
  const content = chatInput.value.trim();
  
  if (content && currentConversation) {
    // Add user message
    const userMessage: ChatMessage = {
      content,
      sender: "user",
      timestamp: new Date()
    };
    
    currentConversation.messages.push(userMessage);
    
    // Update UI
    addMessageToUI(userMessage);
    
    // Clear input
    chatInput.value = "";
    
    // Insert the message into the document
    insertMessageToDocument(content);
    
    // Process the message and generate a response
    processUserMessage(content);
    
    // Update conversation title if it's the first user message
    if (currentConversation.messages.length === 2) {
      currentConversation.title = content.substring(0, 30) + (content.length > 30 ? "..." : "");
      updatePastConversationsUI();
    }
    
    // Save to storage
    saveConversations();
  }
}

/**
 * Process user message and generate a response
 */
async function processUserMessage(content: string): Promise<void> {
  try {
    // In a real implementation, this would call an AI service
    // For now, we'll just echo back a simple response
    
    // Simulate processing delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Add assistant response
    const assistantMessage: ChatMessage = {
      content: `I received your message: "${content}". This is a placeholder response. In a real implementation, this would be generated by an AI service.`,
      sender: "assistant",
      timestamp: new Date()
    };
    
    if (currentConversation) {
      currentConversation.messages.push(assistantMessage);
      
      // Update UI
      addMessageToUI(assistantMessage);
      
      // Save to storage
      saveConversations();
    }
  } catch (error) {
    console.error("Error processing message:", error);
    
    // Add error message
    const errorMessage: ChatMessage = {
      content: "Sorry, I encountered an error processing your message. Please try again.",
      sender: "assistant",
      timestamp: new Date()
    };
    
    if (currentConversation) {
      currentConversation.messages.push(errorMessage);
      
      // Update UI
      addMessageToUI(errorMessage);
      
      // Save to storage
      saveConversations();
    }
  }
}

/**
 * Add a message to the UI
 */
function addMessageToUI(message: ChatMessage): void {
  const chatMessages = document.getElementById("chat-messages");
  
  if (chatMessages) {
    // Use the template to create a new message element
    const template = document.getElementById("message-template") as HTMLTemplateElement;
    if (!template) {
      console.error("Message template not found");
      return;
    }
    
    // Clone the template content
    const messageElement = template.content.cloneNode(true) as DocumentFragment;
    const messageDiv = messageElement.querySelector(".message") as HTMLDivElement;
    
    // Add the appropriate class based on sender
    messageDiv.classList.add(message.sender);
    
    // Set the message content
    const contentElement = messageDiv.querySelector(".message-content") as HTMLDivElement;
    contentElement.textContent = message.content;
    
    // Add the message to the chat container
    chatMessages.appendChild(messageElement);
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
}

/**
 * Insert a message into the Word document
 */
async function insertMessageToDocument(text: string): Promise<void> {
  try {
    await Word.run(async (context) => {
      // Insert text at the current selection
      const range = context.document.getSelection();
      range.insertText(text, Word.InsertLocation.replace);
      
      await context.sync();
      
      // Show a success message (optional)
      const statusElement = document.createElement("div");
      statusElement.className = "status-message";
      statusElement.textContent = "Text inserted into document!";
      document.body.appendChild(statusElement);
      
      // Remove the status message after a few seconds
      setTimeout(() => {
        statusElement.remove();
      }, 3000);
    });
  } catch (error) {
    console.error("Error inserting text to document:", error);
    // Show error message to user
    alert("Failed to insert text into document. Please try again.");
  }
}

/**
 * Save conversations to local storage
 */
function saveConversations(): void {
  try {
    localStorage.setItem("askJuniorConversations", JSON.stringify(conversations));
  } catch (error) {
    console.error("Error saving conversations:", error);
  }
}

/**
 * Load past conversations from local storage
 */
function loadPastConversations(): void {
  try {
    const savedConversations = localStorage.getItem("askJuniorConversations");
    
    if (savedConversations) {
      conversations = JSON.parse(savedConversations);
      
      // Set current conversation to the most recent one
      if (conversations.length > 0) {
        currentConversation = conversations[conversations.length - 1];
        
        // Update UI with current conversation messages
        renderCurrentConversation();
      }
      
      // Update past conversations UI
      updatePastConversationsUI();
    }
  } catch (error) {
    console.error("Error loading conversations:", error);
  }
}

/**
 * Render the current conversation in the UI
 */
function renderCurrentConversation(): void {
  const chatMessages = document.getElementById("chat-messages");
  
  if (chatMessages && currentConversation) {
    // Clear existing messages
    chatMessages.innerHTML = "";
    
    // Add all messages
    currentConversation.messages.forEach(message => {
      addMessageToUI(message);
    });
  }
}

/**
 * Update the past conversations UI
 */
function updatePastConversationsUI(): void {
  const pastConversationsList = document.getElementById("past-conversations");
  
  if (pastConversationsList) {
    // Clear existing items
    pastConversationsList.innerHTML = "";
    
    // Sort conversations by timestamp (newest first)
    const sortedConversations = [...conversations].sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );
    
    // Add conversation items
    sortedConversations.forEach(conversation => {
      const listItem = document.createElement("li");
      listItem.textContent = conversation.title;
      listItem.dataset.id = conversation.id;
      
      // Add click event to load conversation
      listItem.addEventListener("click", () => {
        loadConversation(conversation.id);
      });
      
      pastConversationsList.appendChild(listItem);
    });
  }
}

/**
 * Load a specific conversation by ID
 */
function loadConversation(id: string): void {
  const conversation = conversations.find(c => c.id === id);
  
  if (conversation) {
    currentConversation = conversation;
    renderCurrentConversation();
  }
}

/**
 * Insert text from the conversation into the document
 */
export async function insertTextToDocument(text: string): Promise<void> {
  return Word.run(async (context) => {
    // Insert text at the current selection
    const range = context.document.getSelection();
    range.insertText(text, Word.InsertLocation.replace);
    
    await context.sync();
  });
}

/**
 * Run the chat functionality
 */
export async function run(): Promise<void> {
  return Word.run(async (context) => {
    /**
     * Insert your Word code here
     */

    // insert a paragraph at the end of the document.
    const paragraph = context.document.body.insertParagraph("Hello World", Word.InsertLocation.end);

    // change the paragraph color to blue.
    paragraph.font.color = "blue";

    await context.sync();
  });
}
